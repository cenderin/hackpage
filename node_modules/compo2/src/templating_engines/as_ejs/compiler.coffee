StringBuilder = require 'string_builder.js'
StringTools = require '../../tools/string_tools'


# Compiles the given segments into a render function.
class Compiler

  constructor: (@segments) ->
    @builder = new StringBuilder
    @callback_level = 0
    @current_segment_number = 0


  # Builds the render string.
  compile: ->
    @builder.append "(function(out, done, escape) {\n"
    @builder.append "  with (this) {\n"

    # Compile all the segments.
    @["compile_#{segment.type}"](segment.data) for segment in @segments

    # We are done compiling the segments --> call 'done()'.
    @builder.append "#{@spaces()}done();\n"

    # Close all the open callbacks.
    while @callback_level > 0
      @callback_level--
      @builder.append "#{@spaces()}});\n"

    # Close the render function.
    @builder.append '  }\n'
    @builder.append '})'

    # Return the result.
    @builder.toString()


  # Returns the correct amount of spaces to prepend to each line.
  spaces: ->
    new Array(@callback_level+3).join '  '


  # Compiles the given text segment.
  compile_text: (data) ->
    data = data.replace /\n/g, ''
    data = data.replace /\s+/g, ' '
    @builder.append "#{@spaces()}out(\"#{data}\");\n"


  # Compiles the given javascript expression.
  compile_jsexp: (data) ->
    @builder.append @spaces()
    @builder.append data.trim()
    @builder.append '\n'


  # Compiles the given if-clause
  compile_jsif: (data) ->
    if StringTools.ends_with data, '{'
      return @compile_jsexp "if #{data}"
    @builder.append @spaces()
    @builder.append "if (#{data}) {\n"
    @callback_level++


  # Compiles the given else-clause
  compile_jselse: (data) ->
    @callback_level--
    @builder.append @spaces()
    @builder.append "} else {\n"
    @callback_level++


  # Compiles the given end-clause
  compile_jsend: (data) ->
    @callback_level--
    @builder.append @spaces()
    @builder.append "}\n"


  # Compiles the given for-loop
  compile_jsfor: (data) ->
    if StringTools.ends_with data, '{'
      return @compile_jsexp "for #{data}"
    @builder.append @spaces()
    @builder.append "for (#{data}) {\n"
    @callback_level++


  # Compiles the given JSOUT expression.
  compile_jsout: (data) ->
    @builder.append "#{@spaces()}out(escape(#{data.trim()}));\n"


  # Compiles the given asynchronous JS expression.
  compile_jsasync: (data) ->
    parts = data.split ','
    @builder.append "#{@spaces()}#{parts[0].trim()}(function(#{parts[1].trim()}) {\n"
    @callback_level++

  # Compiles the given asynchronous JS expression.
  compile_jssection: (data) ->
    @builder.append "#{@spaces()}out('section #{data} here');\n"



module.exports = Compiler
