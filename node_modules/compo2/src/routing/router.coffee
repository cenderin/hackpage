ArrayTools = require '../tools/array_tools'
CoffeeScriptRequestHandler = require '../request_handlers/coffeescript_request_handler.coffee'
FileTools = require '../tools/file_tools.coffee'
Node = require './node'
QueryString = require 'querystring'
Section = require '../section.coffee'
SectionRequestHandler = require '../request_handlers/section_request_handler.coffee'
StaticFileRequestHandler = require '../request_handlers/static_file_request_handler.coffee'
StringTools = require '../tools/string_tools'
exec = require('child_process').exec


# Computes all the routes.
# Routes map incoming URLs to objects that should be rendered as a result.
class Router

  constructor: (@configuration={}) ->

    # The routing table.
    @routes = new Node

    # The directory where the sections are stored.
    @www_root = @configuration['www_root'] or 'www'

    # List of regex that match files that should not be exposed to the public.
    @hidden_filenames = [
      /\/_[^\/]+$/                  # Files beginning with an underscore.
      /\/_.*\.html[a-z\.]*$/        # Partials whose parent directory starts with an underscore
    ]


  # Adds the given url, method, and handler to the routing table.
  add_route: (method, url, handler) ->
    path = url.split '/'
    [routeNode, param_names] = @routes.add path
    throw "Duplicate route: #{method} #{url}" if routeNode.handlers[method]
    routeNode.handlers[method] = handler
    routeNode.param_names = param_names


  # Registers the url and request handler for the file with the given path
  # in the routing table.
  create_handler: (file_path, all_routes) ->

    # Ignore empty paths.
    return unless file_path

    # Ignore hidden files.
    return if @is_hidden_filename file_path

    # Handle sections with views only.
    for view_type in @configuration['view_types']
      if StringTools.ends_with file_path, view_type
        [method, url] = @section_url file_path
        @add_route method, url, new SectionRequestHandler(file_path, @configuration)
        return

    # Handle sections with a controller.
    if StringTools.ends_with file_path, '_controller.coffee'

      # Ignore sections that have a view
      # because we have already created a handler for them.
      section = new Section file_path
      return if ArrayTools.any section.view_filenames(), (filename) -> all_routes.indexOf(filename) > -1

      [method, url] = @section_url file_path
      @add_route method, url, new SectionRequestHandler(file_path, @configuration)
      return

    # Handle CoffeeScript assets.
    if StringTools.ends_with file_path, '.coffee'
      [method, url] = @asset_url file_path
      url = url.replace /\.coffee$/, '.js'
      @add_route method, url, new CoffeeScriptRequestHandler(file_path)
      return

    # Here, the file is considered a static asset file.
    [method, url] = @asset_url file_path
    @add_route method, url, new StaticFileRequestHandler(file_path)


  # Returns a routing table.
  find_routes: (done) ->
    exec "find #{@www_root} -type f", (err, stdout, stderr) =>
      all_routes = stdout.split('\n')
      @create_handler(file, all_routes) for file in all_routes
      done()


  # Returns the request handler for the given url and method.
  get_handler: (method, url) ->
    # Add the data portion of the URL to the @params hash.
    url_segments = url.split '?'
    if url_segments.length == 1
      data = {}
    else
      data = QueryString.parse url_segments[1]

    # Find the request handler.
    [routeNode, param_values] = @routes.get url_segments[0].split '/'
    return [undefined, {}] unless routeNode?.handlers[method]
    data[param_name] = param_values[i] for param_name, i in routeNode.param_names
    [routeNode.handlers[method], data]


  # Returns whether the given filename should be hidden.
  is_hidden_filename: (filename) ->
    ArrayTools.any @hidden_filenames, (hidden_regex) -> hidden_regex.test filename


  # Returns the key under which the given URL accessible by the given method is stored in the routing table.
  routes_key: (method, url) ->
    "#{method} #{url}"


  # Returns the URL of the section in the given file path.
  section_url: (file_path) =>
    url = file_path.substring(@www_root.length, file_path.lastIndexOf('/'))

    # Handle special path for root directory.
    url = '/' if url == ''

    # Determine the http method.
    if StringTools.ends_with url, '/$index'
      method = 'GET'
      url = url.slice 0, -7
    else if StringTools.ends_with url, '/$new'
      method = 'GET'
      url = "#{url.slice(0, -5)}/new"
    else if StringTools.ends_with url, '/$create'
      method = 'POST'
      url = url.slice 0, -8
    else if StringTools.ends_with url, '/$get'
      method = 'GET'
      url = url.slice 0, -5
    else if StringTools.ends_with url, '/$post'
      method = 'POST'
      url = url.slice 0, -6
    else if StringTools.ends_with url, '/$put'
      method = 'PUT'
      url = url.slice 0, -5
    else if StringTools.ends_with url, '/$delete'
      method = 'DELETE'
      url = url.slice 0, -8
    else if StringTools.ends_with url, '/$show'
      method = 'GET'
      url = "#{url.slice(0, -6)}/:id"
    else if StringTools.ends_with url, '/$edit'
      method = 'GET'
      url = "#{url.slice(0, -6)}/:id/edit"
    else if StringTools.ends_with url, '/$update'
      method = 'PUT'
      url = "#{url.slice(0, -8)}/:id"
    else if StringTools.ends_with url, '/$destroy'
      method = 'DELETE'
      url = "#{url.slice(0, -9)}/:id"
    else
      method = 'GET'

    [method, url]


  # Returns the URL for the given file path.
  asset_url: (file_path) ->
    ['GET', file_path.substr @www_root.length]



module.exports = Router
